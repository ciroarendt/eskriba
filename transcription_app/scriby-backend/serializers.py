"""
Scriby - Enterprise-grade AI transcription and meeting analysis platform
Django REST Framework Serializers for production-ready API endpoints

Author: Generated by Claude 3.5 Sonnet
Date: 2025-08-06
Tech Stack: Django REST Framework, JWT Authentication, File Upload
"""

from rest_framework import serializers
from rest_framework.validators import UniqueValidator
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _
from django.db import transaction
from decimal import Decimal
import mimetypes
import os

from .models import (
    User, UserProfile, SubscriptionPlan, Recording, Transcription, 
    Analysis, UsageMetrics, BillingTransaction, AuditLog
)


class DynamicFieldsMixin:
    """
    Mixin to dynamically include/exclude fields based on request context.
    """
    def __init__(self, *args, **kwargs):
        # Don't pass the 'fields' arg up to the superclass
        fields = kwargs.pop('fields', None)
        exclude = kwargs.pop('exclude', None)
        
        # Instantiate the superclass normally
        super().__init__(*args, **kwargs)

        if fields is not None:
            # Drop any fields that are not specified in the `fields` argument.
            allowed = set(fields)
            existing = set(self.fields)
            for field_name in existing - allowed:
                self.fields.pop(field_name)
                
        if exclude is not None:
            # Remove fields specified in exclude
            for field_name in exclude:
                self.fields.pop(field_name, None)


class UserProfileSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    """
    Serializer for UserProfile with preferences and usage tracking.
    """
    total_transcription_hours = serializers.SerializerMethodField()
    
    class Meta:
        model = UserProfile
        fields = [
            'default_language', 'timezone', 'notification_preferences',
            'api_rate_limit_per_hour', 'max_file_size_mb', 'max_recording_duration_minutes',
            'total_transcription_minutes', 'total_transcription_hours', 'total_api_calls',
            'last_api_call_at', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'total_transcription_minutes', 'total_api_calls', 'last_api_call_at',
            'created_at', 'updated_at'
        ]

    def get_total_transcription_hours(self, obj):
        """Convert minutes to hours for better UX."""
        return round(obj.total_transcription_minutes / 60, 2) if obj.total_transcription_minutes else 0


class SubscriptionPlanSerializer(serializers.ModelSerializer):
    """
    Serializer for SubscriptionPlan with pricing and feature information.
    """
    yearly_discount_percentage = serializers.SerializerMethodField()
    transcription_hours_monthly = serializers.SerializerMethodField()
    
    class Meta:
        model = SubscriptionPlan
        fields = [
            'id', 'name', 'slug', 'description', 'price_monthly', 'price_yearly',
            'yearly_discount_percentage', 'monthly_transcription_minutes', 
            'transcription_hours_monthly', 'max_file_size_mb', 'max_recording_duration_minutes',
            'api_rate_limit_per_hour', 'features', 'is_active', 'sort_order'
        ]
        read_only_fields = ['id', 'slug', 'sort_order']

    def get_yearly_discount_percentage(self, obj):
        """Calculate yearly discount percentage."""
        if obj.price_yearly and obj.price_monthly:
            yearly_equivalent = obj.price_monthly * 12
            discount = (yearly_equivalent - obj.price_yearly) / yearly_equivalent * 100
            return round(discount, 1)
        return 0

    def get_transcription_hours_monthly(self, obj):
        """Convert minutes to hours for better UX."""
        return round(obj.monthly_transcription_minutes / 60, 1)


class UserSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    """
    Comprehensive User serializer with profile and subscription information.
    """
    profile = UserProfileSerializer(read_only=True)
    subscription_plan_details = SubscriptionPlanSerializer(source='subscription_plan', read_only=True)
    full_name = serializers.CharField(read_only=True)
    monthly_transcription_hours = serializers.SerializerMethodField()
    usage_percentage = serializers.SerializerMethodField()
    
    class Meta:
        model = User
        fields = [
            'id', 'username', 'email', 'first_name', 'last_name', 'full_name',
            'subscription_plan', 'subscription_plan_details', 'subscription_status',
            'monthly_transcription_minutes', 'monthly_transcription_hours', 'monthly_api_calls',
            'total_recordings', 'usage_percentage', 'profile', 'created_at', 'updated_at',
            'last_login_at', 'trial_ends_at'
        ]
        read_only_fields = [
            'id', 'monthly_transcription_minutes', 'monthly_api_calls', 'total_recordings',
            'created_at', 'updated_at', 'last_login_at'
        ]
        extra_kwargs = {
            'email': {'validators': [UniqueValidator(queryset=User.objects.all())]},
        }

    def get_monthly_transcription_hours(self, obj):
        """Convert minutes to hours for better UX."""
        return round(obj.monthly_transcription_minutes / 60, 2)

    def get_usage_percentage(self, obj):
        """Calculate usage percentage based on subscription plan."""
        if obj.subscription_plan and obj.subscription_plan.monthly_transcription_minutes > 0:
            percentage = (obj.monthly_transcription_minutes / obj.subscription_plan.monthly_transcription_minutes) * 100
            return min(round(percentage, 1), 100)
        return 0


class UserRegistrationSerializer(serializers.ModelSerializer):
    """
    User registration serializer with email verification and password validation.
    """
    password = serializers.CharField(write_only=True, validators=[validate_password])
    password_confirm = serializers.CharField(write_only=True)
    terms_accepted = serializers.BooleanField(write_only=True)
    
    class Meta:
        model = User
        fields = [
            'username', 'email', 'first_name', 'last_name', 
            'password', 'password_confirm', 'terms_accepted'
        ]
        extra_kwargs = {
            'email': {'validators': [UniqueValidator(queryset=User.objects.all())]},
            'username': {'validators': [UniqueValidator(queryset=User.objects.all())]},
        }

    def validate(self, attrs):
        """Validate password confirmation and terms acceptance."""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                'password_confirm': _("Password confirmation doesn't match password.")
            })
        
        if not attrs.get('terms_accepted'):
            raise serializers.ValidationError({
                'terms_accepted': _("You must accept the terms and conditions.")
            })
        
        return attrs

    def create(self, validated_data):
        """Create user with hashed password and default subscription."""
        validated_data.pop('password_confirm')
        validated_data.pop('terms_accepted')
        
        with transaction.atomic():
            user = User.objects.create_user(**validated_data)
            # Set default trial subscription
            try:
                trial_plan = SubscriptionPlan.objects.get(slug='trial')
                user.subscription_plan = trial_plan
                user.save()
            except SubscriptionPlan.DoesNotExist:
                pass
            
        return user


class LoginSerializer(serializers.Serializer):
    """
    Login serializer with email/username and password authentication.
    """
    email_or_username = serializers.CharField()
    password = serializers.CharField(write_only=True)
    
    def validate(self, attrs):
        """Authenticate user with email or username."""
        email_or_username = attrs.get('email_or_username')
        password = attrs.get('password')
        
        if email_or_username and password:
            # Try to authenticate with email first, then username
            user = None
            if '@' in email_or_username:
                try:
                    user_obj = User.objects.get(email=email_or_username)
                    user = authenticate(username=user_obj.username, password=password)
                except User.DoesNotExist:
                    pass
            else:
                user = authenticate(username=email_or_username, password=password)
            
            if not user:
                raise serializers.ValidationError(_('Invalid credentials.'))
            
            if not user.is_active:
                raise serializers.ValidationError(_('User account is disabled.'))
            
            attrs['user'] = user
            return attrs
        else:
            raise serializers.ValidationError(_('Must include email/username and password.'))


class RecordingUploadSerializer(serializers.ModelSerializer):
    """
    Recording upload serializer with file validation and metadata extraction.
    """
    audio_file = serializers.FileField()
    
    class Meta:
        model = Recording
        fields = [
            'title', 'description', 'audio_file', 'language', 'tags'
        ]

    def validate_audio_file(self, value):
        """Validate audio file format, size, and duration."""
        # Check file size (max from user profile or default 100MB)
        user = self.context['request'].user
        max_size_mb = user.profile.max_file_size_mb if hasattr(user, 'profile') else 100
        max_size_bytes = max_size_mb * 1024 * 1024
        
        if value.size > max_size_bytes:
            raise serializers.ValidationError(
                f'File size cannot exceed {max_size_mb}MB. Current size: {value.size / (1024*1024):.1f}MB'
            )
        
        # Check file format
        allowed_formats = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/flac', 'audio/ogg']
        content_type = value.content_type
        
        if content_type not in allowed_formats:
            raise serializers.ValidationError(
                f'Unsupported file format: {content_type}. Allowed formats: MP3, WAV, M4A, FLAC, OGG'
            )
        
        return value

    def create(self, validated_data):
        """Create recording with metadata extraction."""
        user = self.context['request'].user
        audio_file = validated_data['audio_file']
        
        # Extract file metadata
        file_extension = os.path.splitext(audio_file.name)[1].lower().lstrip('.')
        format_mapping = {
            'mp3': 'mp3', 'wav': 'wav', 'm4a': 'm4a', 
            'flac': 'flac', 'ogg': 'ogg'
        }
        
        recording = Recording.objects.create(
            user=user,
            original_filename=audio_file.name,
            file_format=format_mapping.get(file_extension, 'mp3'),
            file_size_bytes=audio_file.size,
            status='uploaded',
            **validated_data
        )
        
        return recording


class RecordingSerializer(DynamicFieldsMixin, serializers.ModelSerializer):
    """
    Comprehensive Recording serializer with transcription and analysis data.
    """
    transcription = serializers.SerializerMethodField()
    analyses = serializers.SerializerMethodField()
    duration_formatted = serializers.CharField(read_only=True)
    file_size_mb = serializers.FloatField(read_only=True)
    user_name = serializers.CharField(source='user.full_name', read_only=True)
    
    class Meta:
        model = Recording
        fields = [
            'id', 'title', 'description', 'duration_seconds', 'duration_formatted',
            'file_size_bytes', 'file_size_mb', 'audio_file', 'original_filename',
            'file_format', 'sample_rate', 'channels', 'bitrate', 'status',
            'language', 'tags', 'user_name', 'transcription', 'analyses',
            'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'file_size_bytes', 'sample_rate', 'channels', 'bitrate',
            'original_filename', 'file_format', 'created_at', 'updated_at'
        ]

    def get_transcription(self, obj):
        """Get transcription data if available."""
        try:
            transcription = obj.transcription
            return {
                'id': transcription.id,
                'text': transcription.text,
                'confidence_score': transcription.confidence_percentage,
                'status': transcription.status,
                'word_count': transcription.word_count,
                'speakers_detected': transcription.speakers_detected,
                'is_manually_edited': transcription.is_manually_edited,
                'created_at': transcription.created_at
            }
        except Transcription.DoesNotExist:
            return None

    def get_analyses(self, obj):
        """Get analysis summaries if available."""
        try:
            transcription = obj.transcription
            analyses = transcription.analyses.all()
            return [
                {
                    'id': analysis.id,
                    'analysis_type': analysis.analysis_type,
                    'confidence_score': analysis.confidence_percentage,
                    'content_preview': analysis.content[:200] + '...' if len(analysis.content) > 200 else analysis.content,
                    'created_at': analysis.created_at
                }
                for analysis in analyses
            ]
        except (Transcription.DoesNotExist, AttributeError):
            return []


class TranscriptionSerializer(serializers.ModelSerializer):
    """
    Transcription serializer with version control and speaker identification.
    """
    confidence_percentage = serializers.FloatField(read_only=True)
    word_count = serializers.IntegerField(read_only=True)
    recording_title = serializers.CharField(source='recording.title', read_only=True)
    
    class Meta:
        model = Transcription
        fields = [
            'id', 'recording', 'recording_title', 'text', 'confidence_score',
            'confidence_percentage', 'word_count', 'srt_format', 'vtt_format',
            'json_format', 'processing_time_seconds', 'api_provider', 'model_version',
            'speakers_detected', 'speaker_labels', 'version', 'is_manually_edited',
            'edit_history', 'status', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'confidence_score', 'processing_time_seconds', 'api_provider',
            'model_version', 'speakers_detected', 'speaker_labels', 'version',
            'edit_history', 'created_at', 'updated_at'
        ]

    def update(self, instance, validated_data):
        """Handle manual text edits with version control."""
        if 'text' in validated_data and validated_data['text'] != instance.text:
            # Create new version for manual edit
            user = self.context['request'].user
            instance.create_new_version(validated_data['text'], user)
            validated_data.pop('text')  # Remove from validated_data since it's handled
        
        return super().update(instance, validated_data)


class AnalysisSerializer(serializers.ModelSerializer):
    """
    Analysis serializer with AI processing details and confidence metrics.
    """
    confidence_percentage = serializers.FloatField(read_only=True)
    sentiment_label = serializers.CharField(read_only=True)
    transcription_title = serializers.CharField(source='transcription.recording.title', read_only=True)
    
    class Meta:
        model = Analysis
        fields = [
            'id', 'transcription', 'transcription_title', 'analysis_type', 'content',
            'structured_data', 'confidence_score', 'confidence_percentage',
            'ai_provider', 'model_version', 'processing_time_seconds', 'tokens_used',
            'sentiment_score', 'sentiment_label', 'emotions', 'template_used',
            'custom_parameters', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'confidence_score', 'ai_provider', 'model_version',
            'processing_time_seconds', 'tokens_used', 'sentiment_score',
            'emotions', 'created_at', 'updated_at'
        ]


class UsageMetricsSerializer(serializers.ModelSerializer):
    """
    Usage metrics serializer for AARRR analytics and business intelligence.
    """
    user_name = serializers.CharField(source='user.full_name', read_only=True)
    days_since_signup = serializers.SerializerMethodField()
    
    class Meta:
        model = UsageMetrics
        fields = [
            'user', 'user_name', 'acquisition_channel', 'first_recording_at',
            'first_transcription_at', 'onboarding_completed_at', 'last_login_at',
            'login_streak_days', 'total_sessions', 'total_revenue', 'lifetime_value',
            'referrals_made', 'referral_code', 'days_since_signup',
            'created_at', 'updated_at'
        ]
        read_only_fields = [
            'total_revenue', 'lifetime_value', 'created_at', 'updated_at'
        ]

    def get_days_since_signup(self, obj):
        """Calculate days since user signup."""
        from django.utils import timezone
        delta = timezone.now() - obj.created_at
        return delta.days


class BillingTransactionSerializer(serializers.ModelSerializer):
    """
    Billing transaction serializer for payment processing and subscription management.
    """
    user_name = serializers.CharField(source='user.full_name', read_only=True)
    subscription_plan_name = serializers.CharField(source='subscription_plan.name', read_only=True)
    
    class Meta:
        model = BillingTransaction
        fields = [
            'id', 'user', 'user_name', 'amount', 'currency', 'description',
            'payment_provider', 'external_transaction_id', 'status',
            'subscription_plan', 'subscription_plan_name', 'billing_period_start',
            'billing_period_end', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'external_transaction_id', 'created_at', 'updated_at'
        ]


class AuditLogSerializer(serializers.ModelSerializer):
    """
    Audit log serializer for compliance and security monitoring.
    """
    user_name = serializers.CharField(source='user.full_name', read_only=True)
    
    class Meta:
        model = AuditLog
        fields = [
            'id', 'user', 'user_name', 'action', 'resource_type', 'resource_id',
            'ip_address', 'user_agent', 'request_data', 'response_data',
            'status_code', 'processing_time_ms', 'created_at'
        ]
        read_only_fields = ['id', 'created_at']


# Bulk operation serializers
class BulkRecordingDeleteSerializer(serializers.Serializer):
    """
    Serializer for bulk recording deletion operations.
    """
    recording_ids = serializers.ListField(
        child=serializers.UUIDField(),
        min_length=1,
        max_length=50
    )
    confirm_deletion = serializers.BooleanField()
    
    def validate_confirm_deletion(self, value):
        """Ensure user confirms bulk deletion."""
        if not value:
            raise serializers.ValidationError(_("You must confirm the deletion operation."))
        return value

    def validate_recording_ids(self, value):
        """Validate that all recordings belong to the requesting user."""
        user = self.context['request'].user
        user_recordings = Recording.objects.filter(user=user, id__in=value)
        
        if len(user_recordings) != len(value):
            invalid_ids = set(value) - set(user_recordings.values_list('id', flat=True))
            raise serializers.ValidationError(
                f"Invalid recording IDs: {list(invalid_ids)}"
            )
        return value


# API Response serializers
class APIResponseSerializer(serializers.Serializer):
    """
    Standard API response format for consistent client handling.
    """
    success = serializers.BooleanField()
    message = serializers.CharField(max_length=255)
    data = serializers.JSONField(required=False)
    errors = serializers.JSONField(required=False)
    meta = serializers.JSONField(required=False)


class PaginatedResponseSerializer(serializers.Serializer):
    """
    Paginated response format for list endpoints.
    """
    count = serializers.IntegerField()
    next = serializers.URLField(allow_null=True)
    previous = serializers.URLField(allow_null=True)
    results = serializers.ListField()


# Health check and status serializers
class HealthCheckSerializer(serializers.Serializer):
    """
    Health check response for monitoring and load balancers.
    """
    status = serializers.CharField()
    timestamp = serializers.DateTimeField()
    version = serializers.CharField()
    database = serializers.CharField()
    redis = serializers.CharField()
    celery = serializers.CharField()


class SystemStatsSerializer(serializers.Serializer):
    """
    System statistics for admin dashboard.
    """
    total_users = serializers.IntegerField()
    active_users_today = serializers.IntegerField()
    total_recordings = serializers.IntegerField()
    total_transcription_minutes = serializers.IntegerField()
    total_revenue = serializers.DecimalField(max_digits=10, decimal_places=2)
    avg_processing_time = serializers.FloatField()
    system_uptime = serializers.CharField()
