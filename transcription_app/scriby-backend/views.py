"""
Scriby - Enterprise-grade AI transcription and meeting analysis platform
Django REST Framework Views for production-ready API endpoints

Author: Generated by Claude 3.5 Sonnet
Date: 2025-08-06
Tech Stack: Django REST Framework, JWT Authentication, Celery, WebSockets
"""

from rest_framework import viewsets, status, permissions, filters
from rest_framework.decorators import action, api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from rest_framework.pagination import PageNumberPagination, CursorPagination
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.throttling import UserRateThrottle, AnonRateThrottle
from django_filters.rest_framework import DjangoFilterBackend
from django.contrib.auth import authenticate, login, logout
from django.db.models import Q, Count, Sum, Avg
from django.utils import timezone
from django.core.cache import cache
from django.conf import settings
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.db import transaction
import json
import logging
from datetime import timedelta

from .models import (
    User, UserProfile, SubscriptionPlan, Recording, Transcription, 
    Analysis, UsageMetrics, BillingTransaction, AuditLog
)
from .serializers import (
    UserSerializer, UserRegistrationSerializer, LoginSerializer,
    UserProfileSerializer, SubscriptionPlanSerializer, RecordingSerializer,
    RecordingUploadSerializer, TranscriptionSerializer, AnalysisSerializer,
    UsageMetricsSerializer, BillingTransactionSerializer, AuditLogSerializer,
    BulkRecordingDeleteSerializer, APIResponseSerializer, HealthCheckSerializer,
    SystemStatsSerializer
)
from .permissions import IsOwnerOrReadOnly, IsSubscriptionActive, HasAPIQuota
from .tasks import process_audio_transcription, generate_ai_analysis
from .utils import log_audit_event, check_user_quota, get_system_stats

logger = logging.getLogger(__name__)


class StandardResultsSetPagination(PageNumberPagination):
    """Standard pagination for list views."""
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100


class RecordingCursorPagination(CursorPagination):
    """Cursor pagination for recordings ordered by creation date."""
    page_size = 20
    ordering = '-created_at'
    cursor_query_param = 'cursor'


class CustomUserRateThrottle(UserRateThrottle):
    """Custom rate throttling based on user subscription plan."""
    
    def get_rate(self):
        """Get rate limit based on user's subscription plan."""
        if hasattr(self.request, 'user') and self.request.user.is_authenticated:
            user = self.request.user
            if hasattr(user, 'profile'):
                rate_limit = user.profile.api_rate_limit_per_hour
                return f"{rate_limit}/hour"
        return "100/hour"  # Default rate


# Authentication Views
class CustomTokenObtainPairView(TokenObtainPairView):
    """Custom JWT token obtain view with audit logging."""
    
    def post(self, request, *args, **kwargs):
        response = super().post(request, *args, **kwargs)
        
        if response.status_code == 200:
            # Log successful login
            serializer = LoginSerializer(data=request.data)
            if serializer.is_valid():
                user = serializer.validated_data.get('user')
                if user:
                    log_audit_event(
                        user=user,
                        action='login',
                        resource_type='authentication',
                        ip_address=request.META.get('REMOTE_ADDR'),
                        user_agent=request.META.get('HTTP_USER_AGENT', ''),
                        request_data={'method': 'jwt_token'}
                    )
                    # Update last login
                    user.last_login_at = timezone.now()
                    user.save(update_fields=['last_login_at'])
        
        return response


class UserRegistrationView(APIView):
    """User registration with email verification and audit logging."""
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]
    
    def post(self, request):
        serializer = UserRegistrationSerializer(data=request.data)
        
        if serializer.is_valid():
            try:
                with transaction.atomic():
                    user = serializer.save()
                    
                    # Generate JWT tokens
                    refresh = RefreshToken.for_user(user)
                    access_token = refresh.access_token
                    
                    # Log registration
                    log_audit_event(
                        user=user,
                        action='user_registration',
                        resource_type='user',
                        ip_address=request.META.get('REMOTE_ADDR'),
                        user_agent=request.META.get('HTTP_USER_AGENT', ''),
                        request_data={'email': user.email}
                    )
                    
                    return Response({
                        'success': True,
                        'message': 'User registered successfully',
                        'data': {
                            'user': UserSerializer(user).data,
                            'tokens': {
                                'refresh': str(refresh),
                                'access': str(access_token),
                            }
                        }
                    }, status=status.HTTP_201_CREATED)
                    
            except Exception as e:
                logger.error(f"User registration failed: {str(e)}")
                return Response({
                    'success': False,
                    'message': 'Registration failed',
                    'errors': {'detail': 'Internal server error'}
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        return Response({
            'success': False,
            'message': 'Validation failed',
            'errors': serializer.errors
        }, status=status.HTTP_400_BAD_REQUEST)


class LogoutView(APIView):
    """User logout with token blacklisting."""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        try:
            refresh_token = request.data.get('refresh_token')
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
            
            # Log logout
            log_audit_event(
                user=request.user,
                action='logout',
                resource_type='authentication',
                ip_address=request.META.get('REMOTE_ADDR'),
                user_agent=request.META.get('HTTP_USER_AGENT', '')
            )
            
            return Response({
                'success': True,
                'message': 'Logged out successfully'
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Logout failed: {str(e)}")
            return Response({
                'success': False,
                'message': 'Logout failed'
            }, status=status.HTTP_400_BAD_REQUEST)


# Main ViewSets
class UserViewSet(viewsets.ModelViewSet):
    """User management ViewSet with profile integration."""
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    throttle_classes = [CustomUserRateThrottle]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        """Return user's own data only."""
        return User.objects.filter(id=self.request.user.id).select_related('profile', 'subscription_plan')
    
    @action(detail=False, methods=['get', 'patch'])
    def profile(self, request):
        """Get or update user profile."""
        user = request.user
        
        if request.method == 'GET':
            serializer = UserProfileSerializer(user.profile)
            return Response(serializer.data)
        
        elif request.method == 'PATCH':
            serializer = UserProfileSerializer(user.profile, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                log_audit_event(
                    user=user,
                    action='profile_update',
                    resource_type='user_profile',
                    request_data=request.data
                )
                return Response(serializer.data)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=False, methods=['get'])
    def usage_stats(self, request):
        """Get user usage statistics."""
        user = request.user
        cache_key = f"user_stats_{user.id}"
        
        # Try to get from cache first
        stats = cache.get(cache_key)
        if not stats:
            stats = {
                'total_recordings': user.recordings.count(),
                'total_transcription_minutes': user.monthly_transcription_minutes,
                'total_api_calls': user.monthly_api_calls,
                'subscription_usage_percentage': 0,
                'recent_activity': user.recordings.filter(
                    created_at__gte=timezone.now() - timedelta(days=7)
                ).count()
            }
            
            if user.subscription_plan:
                usage_pct = (user.monthly_transcription_minutes / 
                           user.subscription_plan.monthly_transcription_minutes) * 100
                stats['subscription_usage_percentage'] = min(usage_pct, 100)
            
            # Cache for 5 minutes
            cache.set(cache_key, stats, 300)
        
        return Response(stats)


class SubscriptionPlanViewSet(viewsets.ReadOnlyModelViewSet):
    """Subscription plans ViewSet for public access."""
    queryset = SubscriptionPlan.objects.filter(is_active=True).order_by('sort_order')
    serializer_class = SubscriptionPlanSerializer
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]


class RecordingViewSet(viewsets.ModelViewSet):
    """Recording management ViewSet with file upload and processing."""
    serializer_class = RecordingSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly, IsSubscriptionActive]
    throttle_classes = [CustomUserRateThrottle]
    pagination_class = RecordingCursorPagination
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['status', 'language', 'file_format']
    search_fields = ['title', 'description', 'tags']
    ordering_fields = ['created_at', 'duration_seconds', 'file_size_bytes']
    ordering = ['-created_at']
    parser_classes = [MultiPartParser, FormParser, JSONParser]
    
    def get_queryset(self):
        """Return user's recordings with optimized queries."""
        return Recording.objects.filter(user=self.request.user).select_related(
            'user'
        ).prefetch_related('transcription', 'transcription__analyses')
    
    def get_serializer_class(self):
        """Use different serializers for different actions."""
        if self.action == 'create':
            return RecordingUploadSerializer
        return RecordingSerializer
    
    def perform_create(self, serializer):
        """Create recording with quota checking and processing trigger."""
        user = self.request.user
        
        # Check user quota
        if not check_user_quota(user, 'recordings'):
            raise permissions.PermissionDenied("Recording quota exceeded")
        
        # Save recording
        recording = serializer.save(user=user)
        
        # Log creation
        log_audit_event(
            user=user,
            action='recording_create',
            resource_type='recording',
            resource_id=str(recording.id),
            request_data={'title': recording.title, 'file_size': recording.file_size_bytes}
        )
        
        # Trigger async transcription processing
        process_audio_transcription.delay(recording.id)
    
    @action(detail=True, methods=['post'])
    def start_transcription(self, request, pk=None):
        """Manually trigger transcription processing."""
        recording = self.get_object()
        
        if recording.status not in ['uploaded', 'failed']:
            return Response({
                'success': False,
                'message': 'Recording is not ready for transcription'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Check transcription quota
        if not check_user_quota(request.user, 'transcription_minutes', recording.duration_seconds / 60):
            return Response({
                'success': False,
                'message': 'Transcription quota exceeded'
            }, status=status.HTTP_403_FORBIDDEN)
        
        # Trigger processing
        task = process_audio_transcription.delay(recording.id)
        
        return Response({
            'success': True,
            'message': 'Transcription started',
            'data': {'task_id': task.id}
        })
    
    @action(detail=True, methods=['get'])
    def transcription_status(self, request, pk=None):
        """Get transcription status and progress."""
        recording = self.get_object()
        
        try:
            transcription = recording.transcription
            return Response({
                'status': transcription.status,
                'confidence_score': transcription.confidence_percentage,
                'word_count': transcription.word_count,
                'processing_time': transcription.processing_time_seconds,
                'created_at': transcription.created_at
            })
        except Transcription.DoesNotExist:
            return Response({
                'status': 'not_started',
                'message': 'Transcription not yet started'
            })
    
    @action(detail=False, methods=['post'])
    def bulk_delete(self, request):
        """Bulk delete recordings with validation."""
        serializer = BulkRecordingDeleteSerializer(data=request.data, context={'request': request})
        
        if serializer.is_valid():
            recording_ids = serializer.validated_data['recording_ids']
            
            with transaction.atomic():
                deleted_count = Recording.objects.filter(
                    user=request.user,
                    id__in=recording_ids
                ).delete()[0]
                
                log_audit_event(
                    user=request.user,
                    action='bulk_recording_delete',
                    resource_type='recording',
                    request_data={'count': deleted_count, 'ids': recording_ids}
                )
            
            return Response({
                'success': True,
                'message': f'Successfully deleted {deleted_count} recordings'
            })
        
        return Response({
            'success': False,
            'errors': serializer.errors
        }, status=status.HTTP_400_BAD_REQUEST)


class TranscriptionViewSet(viewsets.ModelViewSet):
    """Transcription management ViewSet with version control."""
    serializer_class = TranscriptionSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    throttle_classes = [CustomUserRateThrottle]
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    filterset_fields = ['status', 'api_provider', 'is_manually_edited']
    search_fields = ['text', 'recording__title']
    
    def get_queryset(self):
        """Return transcriptions for user's recordings."""
        return Transcription.objects.filter(
            recording__user=self.request.user
        ).select_related('recording').prefetch_related('analyses')
    
    @action(detail=True, methods=['post'])
    def generate_analysis(self, request, pk=None):
        """Trigger AI analysis generation."""
        transcription = self.get_object()
        analysis_type = request.data.get('analysis_type', 'summary')
        
        if not check_user_quota(request.user, 'ai_analysis'):
            return Response({
                'success': False,
                'message': 'AI analysis quota exceeded'
            }, status=status.HTTP_403_FORBIDDEN)
        
        # Trigger async analysis
        task = generate_ai_analysis.delay(transcription.id, analysis_type)
        
        return Response({
            'success': True,
            'message': 'Analysis generation started',
            'data': {'task_id': task.id, 'analysis_type': analysis_type}
        })
    
    @action(detail=True, methods=['get'])
    def export(self, request, pk=None):
        """Export transcription in different formats."""
        transcription = self.get_object()
        format_type = request.query_params.get('format', 'json')
        
        if format_type == 'srt':
            content = transcription.srt_format
            content_type = 'text/plain'
        elif format_type == 'vtt':
            content = transcription.vtt_format
            content_type = 'text/vtt'
        elif format_type == 'txt':
            content = transcription.text
            content_type = 'text/plain'
        else:
            content = transcription.json_format
            content_type = 'application/json'
        
        response = Response(content, content_type=content_type)
        response['Content-Disposition'] = f'attachment; filename="transcription.{format_type}"'
        return response


class AnalysisViewSet(viewsets.ReadOnlyModelViewSet):
    """Analysis results ViewSet for viewing AI-generated content."""
    serializer_class = AnalysisSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    throttle_classes = [CustomUserRateThrottle]
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    filterset_fields = ['analysis_type', 'ai_provider']
    search_fields = ['content', 'transcription__recording__title']
    
    def get_queryset(self):
        """Return analyses for user's transcriptions."""
        return Analysis.objects.filter(
            transcription__recording__user=self.request.user
        ).select_related('transcription__recording')


# Analytics and Reporting Views
class AnalyticsView(APIView):
    """Analytics dashboard data for admin users."""
    permission_classes = [permissions.IsAuthenticated]
    throttle_classes = [CustomUserRateThrottle]
    
    def get(self, request):
        """Get comprehensive analytics data."""
        user = request.user
        cache_key = f"analytics_{user.id}"
        
        # Check cache first
        analytics_data = cache.get(cache_key)
        if not analytics_data:
            # Calculate analytics
            recordings = Recording.objects.filter(user=user)
            transcriptions = Transcription.objects.filter(recording__user=user)
            
            analytics_data = {
                'overview': {
                    'total_recordings': recordings.count(),
                    'total_transcriptions': transcriptions.count(),
                    'total_duration_hours': recordings.aggregate(
                        total=Sum('duration_seconds')
                    )['total'] / 3600 if recordings.exists() else 0,
                    'avg_confidence_score': transcriptions.aggregate(
                        avg=Avg('confidence_score')
                    )['avg'] or 0,
                },
                'monthly_stats': {
                    'recordings_this_month': recordings.filter(
                        created_at__gte=timezone.now().replace(day=1)
                    ).count(),
                    'transcription_minutes_used': user.monthly_transcription_minutes,
                    'api_calls_made': user.monthly_api_calls,
                },
                'recent_activity': recordings.filter(
                    created_at__gte=timezone.now() - timedelta(days=7)
                ).values('created_at__date').annotate(count=Count('id')),
            }
            
            # Cache for 10 minutes
            cache.set(cache_key, analytics_data, 600)
        
        return Response(analytics_data)


# System Health and Status Views
@api_view(['GET'])
@permission_classes([permissions.AllowAny])
def health_check(request):
    """System health check endpoint."""
    try:
        # Check database
        User.objects.first()
        db_status = "healthy"
    except Exception:
        db_status = "unhealthy"
    
    # Check Redis
    try:
        cache.set('health_check', 'ok', 10)
        redis_status = "healthy" if cache.get('health_check') == 'ok' else "unhealthy"
    except Exception:
        redis_status = "unhealthy"
    
    health_data = {
        'status': 'healthy' if db_status == 'healthy' and redis_status == 'healthy' else 'unhealthy',
        'timestamp': timezone.now(),
        'version': getattr(settings, 'VERSION', '1.0.0'),
        'database': db_status,
        'redis': redis_status,
        'celery': 'unknown'  # Would need Celery inspection
    }
    
    serializer = HealthCheckSerializer(health_data)
    return Response(serializer.data)


@api_view(['GET'])
@permission_classes([permissions.IsAdminUser])
def system_stats(request):
    """System statistics for admin dashboard."""
    stats = get_system_stats()
    serializer = SystemStatsSerializer(stats)
    return Response(serializer.data)


# WebSocket support placeholder
class WebSocketNotificationView(APIView):
    """WebSocket notification endpoint for real-time updates."""
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        """Send real-time notification to user."""
        # This would integrate with Django Channels for WebSocket support
        return Response({
            'success': True,
            'message': 'WebSocket notification system ready'
        })


# Error handling views
@csrf_exempt
def handler404(request, exception=None):
    """Custom 404 handler for API endpoints."""
    return JsonResponse({
        'success': False,
        'message': 'Endpoint not found',
        'error_code': 'NOT_FOUND'
    }, status=404)


@csrf_exempt
def handler500(request):
    """Custom 500 handler for API endpoints."""
    return JsonResponse({
        'success': False,
        'message': 'Internal server error',
        'error_code': 'INTERNAL_ERROR'
    }, status=500)
