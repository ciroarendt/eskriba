"""
Scriby - Enterprise-grade AI transcription and meeting analysis platform
Django Models for production-ready scalable web application

Author: Generated by Claude 3.5 Sonnet
Date: 2025-08-06
Tech Stack: Django 4.2, PostgreSQL, Celery, Redis, OpenAI Whisper
"""

import uuid
from decimal import Decimal
from django.contrib.auth.models import AbstractUser
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db import models
from django.utils import timezone
from django.urls import reverse
import json


class TimestampedModel(models.Model):
    """Abstract base model with created_at and updated_at timestamps."""
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True, db_index=True)

    class Meta:
        abstract = True


class User(AbstractUser):
    """
    Custom User model extending AbstractUser with subscription and API usage tracking.
    Optimized for multi-tenant SaaS platform with billing integration.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True, db_index=True)
    first_name = models.CharField(max_length=150)
    last_name = models.CharField(max_length=150)
    
    # Subscription and billing
    subscription_plan = models.ForeignKey(
        'SubscriptionPlan', 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='users'
    )
    subscription_status = models.CharField(
        max_length=20,
        choices=[
            ('trial', 'Trial'),
            ('active', 'Active'),
            ('past_due', 'Past Due'),
            ('canceled', 'Canceled'),
            ('unpaid', 'Unpaid'),
        ],
        default='trial',
        db_index=True
    )
    
    # API usage tracking
    monthly_transcription_minutes = models.PositiveIntegerField(default=0)
    monthly_api_calls = models.PositiveIntegerField(default=0)
    total_recordings = models.PositiveIntegerField(default=0)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_login_at = models.DateTimeField(null=True, blank=True)
    trial_ends_at = models.DateTimeField(null=True, blank=True)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username', 'first_name', 'last_name']

    class Meta:
        db_table = 'users'
        indexes = [
            models.Index(fields=['email', 'subscription_status']),
            models.Index(fields=['created_at', 'subscription_plan']),
        ]

    def __str__(self):
        return f"{self.get_full_name()} ({self.email})"

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}".strip()

    def can_transcribe_minutes(self, minutes):
        """Check if user can transcribe given minutes based on plan limits."""
        if not self.subscription_plan:
            return False
        monthly_limit = self.subscription_plan.monthly_transcription_minutes
        return (self.monthly_transcription_minutes + minutes) <= monthly_limit

    def reset_monthly_usage(self):
        """Reset monthly usage counters (called by Celery task)."""
        self.monthly_transcription_minutes = 0
        self.monthly_api_calls = 0
        self.save(update_fields=['monthly_transcription_minutes', 'monthly_api_calls'])


class UserProfile(TimestampedModel):
    """
    Extended user profile with preferences, quotas, and detailed usage tracking.
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    
    # User preferences
    default_language = models.CharField(max_length=10, default='en-US')
    timezone = models.CharField(max_length=50, default='UTC')
    notification_preferences = models.JSONField(default=dict)
    
    # API and usage quotas
    api_rate_limit_per_hour = models.PositiveIntegerField(default=100)
    max_file_size_mb = models.PositiveIntegerField(default=100)
    max_recording_duration_minutes = models.PositiveIntegerField(default=180)
    
    # Analytics and tracking
    total_transcription_minutes = models.PositiveIntegerField(default=0)
    total_api_calls = models.PositiveIntegerField(default=0)
    last_api_call_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'user_profiles'

    def __str__(self):
        return f"Profile for {self.user.full_name}"


class SubscriptionPlan(TimestampedModel):
    """
    Subscription plans with features, limits, and pricing for SaaS billing.
    """
    name = models.CharField(max_length=100, unique=True)
    slug = models.SlugField(unique=True, db_index=True)
    description = models.TextField()
    
    # Pricing
    price_monthly = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        validators=[MinValueValidator(Decimal('0.00'))]
    )
    price_yearly = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        validators=[MinValueValidator(Decimal('0.00'))],
        null=True, 
        blank=True
    )
    
    # Features and limits
    monthly_transcription_minutes = models.PositiveIntegerField()
    max_file_size_mb = models.PositiveIntegerField(default=100)
    max_recording_duration_minutes = models.PositiveIntegerField(default=180)
    api_rate_limit_per_hour = models.PositiveIntegerField(default=100)
    
    # Feature flags
    features = models.JSONField(default=dict)  # {"ai_analysis": true, "custom_templates": false}
    is_active = models.BooleanField(default=True)
    sort_order = models.PositiveIntegerField(default=0)

    class Meta:
        db_table = 'subscription_plans'
        ordering = ['sort_order', 'price_monthly']

    def __str__(self):
        return f"{self.name} (${self.price_monthly}/month)"

    def get_absolute_url(self):
        return reverse('subscription_plan_detail', kwargs={'slug': self.slug})


class Recording(TimestampedModel):
    """
    Audio recording model with metadata, file storage, and processing status.
    Supports cloud storage integration (S3/GCS) and multiple audio formats.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='recordings')
    
    # Recording metadata
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    duration_seconds = models.PositiveIntegerField(null=True, blank=True)
    file_size_bytes = models.PositiveBigIntegerField(null=True, blank=True)
    
    # File storage
    audio_file = models.FileField(upload_to='recordings/%Y/%m/%d/')
    original_filename = models.CharField(max_length=255)
    file_format = models.CharField(
        max_length=10,
        choices=[
            ('mp3', 'MP3'),
            ('wav', 'WAV'),
            ('m4a', 'M4A'),
            ('flac', 'FLAC'),
            ('ogg', 'OGG'),
        ]
    )
    
    # Audio properties
    sample_rate = models.PositiveIntegerField(null=True, blank=True)
    channels = models.PositiveSmallIntegerField(null=True, blank=True)
    bitrate = models.PositiveIntegerField(null=True, blank=True)
    
    # Processing status
    status = models.CharField(
        max_length=20,
        choices=[
            ('uploading', 'Uploading'),
            ('uploaded', 'Uploaded'),
            ('processing', 'Processing'),
            ('completed', 'Completed'),
            ('failed', 'Failed'),
            ('archived', 'Archived'),
        ],
        default='uploading',
        db_index=True
    )
    
    # Metadata
    language = models.CharField(max_length=10, default='en-US')
    tags = models.JSONField(default=list)
    
    class Meta:
        db_table = 'recordings'
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['created_at', 'status']),
            models.Index(fields=['user', 'created_at']),
        ]

    def __str__(self):
        return f"{self.title} ({self.user.full_name})"

    @property
    def duration_formatted(self):
        """Return duration in HH:MM:SS format."""
        if not self.duration_seconds:
            return "00:00:00"
        hours = self.duration_seconds // 3600
        minutes = (self.duration_seconds % 3600) // 60
        seconds = self.duration_seconds % 60
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

    @property
    def file_size_mb(self):
        """Return file size in MB."""
        if not self.file_size_bytes:
            return 0
        return round(self.file_size_bytes / (1024 * 1024), 2)

    def get_absolute_url(self):
        return reverse('recording_detail', kwargs={'pk': self.pk})


class Transcription(TimestampedModel):
    """
    Transcription results with confidence scores, multiple formats, and version control.
    Supports speaker identification, timestamps, and manual editing capabilities.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    recording = models.OneToOneField(Recording, on_delete=models.CASCADE, related_name='transcription')
    
    # Transcription content
    text = models.TextField()
    confidence_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        null=True, 
        blank=True
    )
    
    # Multiple format support
    srt_format = models.TextField(blank=True)  # SubRip format
    vtt_format = models.TextField(blank=True)  # WebVTT format
    json_format = models.JSONField(default=dict)  # Structured data with timestamps
    
    # Processing details
    processing_time_seconds = models.FloatField(null=True, blank=True)
    api_provider = models.CharField(
        max_length=20,
        choices=[
            ('openai_whisper', 'OpenAI Whisper'),
            ('google_speech', 'Google Speech-to-Text'),
            ('azure_speech', 'Azure Speech Services'),
        ],
        default='openai_whisper'
    )
    model_version = models.CharField(max_length=50, blank=True)
    
    # Speaker identification
    speakers_detected = models.PositiveSmallIntegerField(default=1)
    speaker_labels = models.JSONField(default=list)  # [{"speaker": "Speaker 1", "segments": [...]}]
    
    # Version control for manual edits
    version = models.PositiveSmallIntegerField(default=1)
    is_manually_edited = models.BooleanField(default=False)
    edit_history = models.JSONField(default=list)
    
    # Status and quality
    status = models.CharField(
        max_length=20,
        choices=[
            ('processing', 'Processing'),
            ('completed', 'Completed'),
            ('failed', 'Failed'),
            ('reviewed', 'Reviewed'),
        ],
        default='processing',
        db_index=True
    )
    
    class Meta:
        db_table = 'transcriptions'
        indexes = [
            models.Index(fields=['recording', 'status']),
            models.Index(fields=['created_at', 'confidence_score']),
        ]

    def __str__(self):
        return f"Transcription for {self.recording.title}"

    @property
    def word_count(self):
        """Return word count of transcription text."""
        return len(self.text.split()) if self.text else 0

    @property
    def confidence_percentage(self):
        """Return confidence score as percentage."""
        return round(self.confidence_score * 100, 1) if self.confidence_score else None

    def create_new_version(self, new_text, edited_by):
        """Create a new version when manually edited."""
        self.edit_history.append({
            'version': self.version,
            'text': self.text,
            'edited_by': str(edited_by),
            'edited_at': timezone.now().isoformat(),
        })
        self.text = new_text
        self.version += 1
        self.is_manually_edited = True
        self.save()


class Analysis(TimestampedModel):
    """
    AI analysis results including summary, topics, action items, and sentiment analysis.
    Supports custom analysis types and confidence metrics for AI outputs.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    transcription = models.ForeignKey(Transcription, on_delete=models.CASCADE, related_name='analyses')
    
    # Analysis type and configuration
    analysis_type = models.CharField(
        max_length=30,
        choices=[
            ('summary', 'Summary'),
            ('meeting_minutes', 'Meeting Minutes'),
            ('action_items', 'Action Items'),
            ('topics', 'Topics'),
            ('sentiment', 'Sentiment Analysis'),
            ('custom', 'Custom Analysis'),
        ],
        db_index=True
    )
    
    # Analysis results
    content = models.TextField()
    structured_data = models.JSONField(default=dict)  # Structured analysis results
    confidence_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        null=True, 
        blank=True
    )
    
    # AI processing details
    ai_provider = models.CharField(
        max_length=20,
        choices=[
            ('openai_gpt4', 'OpenAI GPT-4'),
            ('openai_gpt4_mini', 'OpenAI GPT-4 Mini'),
            ('google_gemini', 'Google Gemini'),
            ('anthropic_claude', 'Anthropic Claude'),
        ],
        default='openai_gpt4_mini'
    )
    model_version = models.CharField(max_length=50, blank=True)
    processing_time_seconds = models.FloatField(null=True, blank=True)
    tokens_used = models.PositiveIntegerField(null=True, blank=True)
    
    # Sentiment analysis specific fields
    sentiment_score = models.FloatField(
        validators=[MinValueValidator(-1.0), MaxValueValidator(1.0)],
        null=True, 
        blank=True
    )
    emotions = models.JSONField(default=dict)  # {"joy": 0.8, "anger": 0.1, ...}
    
    # Custom analysis
    template_used = models.CharField(max_length=100, blank=True)
    custom_parameters = models.JSONField(default=dict)
    
    class Meta:
        db_table = 'analyses'
        indexes = [
            models.Index(fields=['transcription', 'analysis_type']),
            models.Index(fields=['created_at', 'analysis_type']),
        ]

    def __str__(self):
        return f"{self.get_analysis_type_display()} for {self.transcription.recording.title}"

    @property
    def confidence_percentage(self):
        """Return confidence score as percentage."""
        return round(self.confidence_score * 100, 1) if self.confidence_score else None

    @property
    def sentiment_label(self):
        """Return sentiment label based on score."""
        if self.sentiment_score is None:
            return None
        if self.sentiment_score > 0.1:
            return "Positive"
        elif self.sentiment_score < -0.1:
            return "Negative"
        else:
            return "Neutral"


class UsageMetrics(TimestampedModel):
    """
    AARRR metrics tracking for business intelligence and user analytics.
    Tracks Acquisition, Activation, Retention, Revenue, and Referral metrics.
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='usage_metrics')
    
    # Acquisition metrics
    acquisition_channel = models.CharField(
        max_length=50,
        choices=[
            ('organic', 'Organic Search'),
            ('paid_search', 'Paid Search'),
            ('social', 'Social Media'),
            ('referral', 'Referral'),
            ('direct', 'Direct'),
            ('email', 'Email Marketing'),
        ],
        blank=True
    )
    
    # Activation metrics
    first_recording_at = models.DateTimeField(null=True, blank=True)
    first_transcription_at = models.DateTimeField(null=True, blank=True)
    onboarding_completed_at = models.DateTimeField(null=True, blank=True)
    
    # Retention metrics
    last_login_at = models.DateTimeField(null=True, blank=True)
    login_streak_days = models.PositiveIntegerField(default=0)
    total_sessions = models.PositiveIntegerField(default=0)
    
    # Revenue metrics
    total_revenue = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        default=Decimal('0.00')
    )
    lifetime_value = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        default=Decimal('0.00')
    )
    
    # Referral metrics
    referrals_made = models.PositiveIntegerField(default=0)
    referral_code = models.CharField(max_length=20, unique=True, null=True, blank=True)
    
    class Meta:
        db_table = 'usage_metrics'
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['acquisition_channel', 'created_at']),
        ]

    def __str__(self):
        return f"Metrics for {self.user.full_name}"


class BillingTransaction(TimestampedModel):
    """
    Billing and payment transaction tracking for subscription management.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='billing_transactions')
    
    # Transaction details
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='USD')
    description = models.CharField(max_length=255)
    
    # Payment processing
    payment_provider = models.CharField(
        max_length=20,
        choices=[
            ('stripe', 'Stripe'),
            ('paypal', 'PayPal'),
            ('apple_pay', 'Apple Pay'),
            ('google_pay', 'Google Pay'),
        ]
    )
    external_transaction_id = models.CharField(max_length=255, unique=True)
    
    # Status tracking
    status = models.CharField(
        max_length=20,
        choices=[
            ('pending', 'Pending'),
            ('completed', 'Completed'),
            ('failed', 'Failed'),
            ('refunded', 'Refunded'),
            ('disputed', 'Disputed'),
        ],
        default='pending',
        db_index=True
    )
    
    # Subscription context
    subscription_plan = models.ForeignKey(
        SubscriptionPlan, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True
    )
    billing_period_start = models.DateTimeField(null=True, blank=True)
    billing_period_end = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'billing_transactions'
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['created_at', 'status']),
            models.Index(fields=['external_transaction_id']),
        ]

    def __str__(self):
        return f"{self.amount} {self.currency} - {self.user.full_name}"


class AuditLog(TimestampedModel):
    """
    Comprehensive audit logging for compliance, security, and debugging.
    Tracks all important user actions and system events.
    """
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    
    # Action details
    action = models.CharField(max_length=100, db_index=True)
    resource_type = models.CharField(max_length=50)
    resource_id = models.CharField(max_length=255, null=True, blank=True)
    
    # Context and metadata
    ip_address = models.GenericIPAddressField(null=True, blank=True)
    user_agent = models.TextField(blank=True)
    request_data = models.JSONField(default=dict)
    response_data = models.JSONField(default=dict)
    
    # Status and timing
    status_code = models.PositiveSmallIntegerField(null=True, blank=True)
    processing_time_ms = models.PositiveIntegerField(null=True, blank=True)
    
    class Meta:
        db_table = 'audit_logs'
        indexes = [
            models.Index(fields=['user', 'action']),
            models.Index(fields=['created_at', 'action']),
            models.Index(fields=['resource_type', 'resource_id']),
        ]

    def __str__(self):
        user_info = f"{self.user.full_name}" if self.user else "Anonymous"
        return f"{self.action} by {user_info} at {self.created_at}"


# Signal handlers for automatic model updates
from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    """Automatically create UserProfile when User is created."""
    if created:
        UserProfile.objects.create(user=instance)

@receiver(post_save, sender=User)
def create_usage_metrics(sender, instance, created, **kwargs):
    """Automatically create UsageMetrics when User is created."""
    if created:
        UsageMetrics.objects.create(user=instance)

@receiver(pre_save, sender=Recording)
def update_user_stats(sender, instance, **kwargs):
    """Update user statistics when recording status changes."""
    if instance.pk:  # Only for existing records
        try:
            old_instance = Recording.objects.get(pk=instance.pk)
            if old_instance.status != 'completed' and instance.status == 'completed':
                instance.user.total_recordings += 1
                if instance.duration_seconds:
                    minutes = instance.duration_seconds / 60
                    instance.user.monthly_transcription_minutes += int(minutes)
                instance.user.save(update_fields=['total_recordings', 'monthly_transcription_minutes'])
        except Recording.DoesNotExist:
            pass
